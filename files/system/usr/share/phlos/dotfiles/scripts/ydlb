#!/usr/bin/env bash
set -euo pipefail

# ------------------------------------------------------------------------------
# ANSI escape code variables.
# ------------------------------------------------------------------------------

# Usage: printf "I ${Red}love${Color_Off} Stack Overflow\n"
# If you are using the echo command, be sure to use the -e flag to allow backslash escapes.
# echo -e "I ${Red}love${Color_Off} Stack Overflow"

# Reset
Color_Off='\033[0m'       # Text Reset

# Regular Colors
Black='\033[0;30m'        # Black
Red='\033[0;31m'          # Red
Green='\033[0;32m'        # Green
Yellow='\033[0;33m'       # Yellow
Blue='\033[0;34m'         # Blue
Purple='\033[0;35m'       # Purple
Cyan='\033[0;36m'         # Cyan
White='\033[0;37m'        # White

# Bold
BBlack='\033[1;30m'       # Black
BRed='\033[1;31m'         # Red
BGreen='\033[1;32m'       # Green
BYellow='\033[1;33m'      # Yellow
BBlue='\033[1;34m'        # Blue
BPurple='\033[1;35m'      # Purple
BCyan='\033[1;36m'        # Cyan
BWhite='\033[1;37m'       # White

# Underline
UBlack='\033[4;30m'       # Black
URed='\033[4;31m'         # Red
UGreen='\033[4;32m'       # Green
UYellow='\033[4;33m'      # Yellow
UBlue='\033[4;34m'        # Blue
UPurple='\033[4;35m'      # Purple
UCyan='\033[4;36m'        # Cyan
UWhite='\033[4;37m'       # White

# Background
On_Black='\033[40m'       # Black
On_Red='\033[41m'         # Red
On_Green='\033[42m'       # Green
On_Yellow='\033[43m'      # Yellow
On_Blue='\033[44m'        # Blue
On_Purple='\033[45m'      # Purple
On_Cyan='\033[46m'        # Cyan
On_White='\033[47m'       # White

# High Intensity
IBlack='\033[0;90m'       # Black
IRed='\033[0;91m'         # Red
IGreen='\033[0;92m'       # Green
IYellow='\033[0;93m'      # Yellow
IBlue='\033[0;94m'        # Blue
IPurple='\033[0;95m'      # Purple
ICyan='\033[0;96m'        # Cyan
IWhite='\033[0;97m'       # White

# Bold High Intensity
BIBlack='\033[1;90m'      # Black
BIRed='\033[1;91m'        # Red
BIGreen='\033[1;92m'      # Green
BIYellow='\033[1;93m'     # Yellow
BIBlue='\033[1;94m'       # Blue
BIPurple='\033[1;95m'     # Purple
BICyan='\033[1;96m'       # Cyan
BIWhite='\033[1;97m'      # White

# High Intensity backgrounds
On_IBlack='\033[0;100m'   # Black
On_IRed='\033[0;101m'     # Red
On_IGreen='\033[0;102m'   # Green
On_IYellow='\033[0;103m'  # Yellow
On_IBlue='\033[0;104m'    # Blue
On_IPurple='\033[0;105m'  # Purple
On_ICyan='\033[0;106m'    # Cyan
On_IWhite='\033[0;107m'   # White

# ------------------------------------------------------------------------------

function append_line_to_file {
    local executor="$FUNCNAME"
    local line="${1}"
    local file="$( expand_path "${2}" )"
    [[ ! -f "${file}" ]] && printf "[${executor}][${BRed}ERROR${Color_Off}] File not found: %s\n" "${file}" && exit 1
    printf '%s\n' "${line}" | tee --append "${file}" > /dev/null
}

function expand_path {
    local py_v="$( python -V | cut -d ' ' -f 2 )"
    if [[ "${py_v}" == '3.'* ]]; then
        python - "$@" << EOF
import argparse
import pathlib

parser = argparse.ArgumentParser(
    description="Normalize input paths",
    formatter_class=argparse.RawDescriptionHelpFormatter,
)

parser.add_argument(
    "paths",
    metavar="P",
    type=str,
    nargs="+",
    help="path to file/folder",
)

args = parser.parse_args()

for p in args.paths:
    p = pathlib.Path(f"{p}").expanduser().resolve()
    print(f"{str(p)}")
EOF
    fi
}

function print_char_line {
    local filler=${1}
    printf "%`tput cols`s" | sed "s/ /${filler}/g"
    printf '\n'
}

function is_url_validators {
    local py_v="$( python -V | cut -d ' ' -f 2 )"
    if [[ "${py_v}" == '3.'* ]]; then
        python - "$@" << EOF
import argparse
import validators

def is_string_an_url(url_string: str) -> bool:
    result = validators.url(url_string)

    if isinstance(result, ValidationFailure):
        return False

    return result


parser = argparse.ArgumentParser(
    description="Check input strings are URLs",
    formatter_class=argparse.RawDescriptionHelpFormatter,
)

parser.add_argument(
    "inputs",
    metavar="I",
    type=str,
    nargs="+",
    help="string to check",
)

args = parser.parse_args()

for i in args.inputs:
    print(f"{is_string_an_url(i)}")
EOF
    fi
}

function is_url_urllib {
    local py_v="$( python -V | cut -d ' ' -f 2 )"
    if [[ "${py_v}" == '3.'* ]]; then
        python - "$@" << EOF
import argparse
from urllib.parse import urlparse

parser = argparse.ArgumentParser(
    description="Check input strings are URLs",
    formatter_class=argparse.RawDescriptionHelpFormatter,
)

parser.add_argument(
    "inputs",
    metavar="I",
    type=str,
    nargs="+",
    help="string to check",
)

args = parser.parse_args()

for i in args.inputs:
    result = urlparse(i)
    if result.scheme and result.netloc:
        print("true")
    else:
        print("false")
EOF
    fi
}

# ------------------------------------------------------------------------------

function usage {
    >&2 cat << EOF
Usage: $0
    [-h/--help]                     Display this help message.

    [-s/--simulate]                 Go through the motions but download nothing.

    [-f/--list-formats]             List formats for all input urls wherever possible.

    [-c/--compress]                 Attempt to compress videos after downloading using vx265opus.

    [-r/--resolution <resolution>]  Set the desired resolution using:
                                    '480' '720' '1080' '1440' '2160' '4k' '4320' '8k'.

    [-t/--write-thumbnail]          Download thumbnail of the video if available
                                    into a separate image file.

    [-d/--write-description]        Write description of the video if available.

    [-n/--no-folder]                Don't put video under special file tree if
                                    one was to be made/used.

    [-a/--audio]                    Download only audio.

    [-i/--playlist-items <items>]   Comma separated playlist_index of the items
                                    to download. You can specify a range using
                                    "[START]:[STOP][:STEP]". For backward
                                    compatibility, START-STOP is also supported.
                                    Use negative indices to count from the right
                                    and negative STEP to download in reverse
                                    order. For example:
                                    "-i 1:3,7,-5::2" used on a
                                    playlist of size 15 will download the items
                                    at index 1,2,3,7,11,13,15.
                                    "-i ::-1" will reverse download the entire playlist

    [-u/--date <YYYYMMDD>]          Download only videos uploaded on this date.
                                    The date can be "YYYYMMDD" or in the format
                                    [now|today|yesterday][-N[day|week|month|year]].
                                    E.g. "--date today-2weeks" downloads only
                                    videos uploaded on the same day two weeks ago

    [-z/--date-before <YYYYMMDD>]   Download only videos uploaded on or before
                                    this date. The date formats accepted is the
                                    same as --date

    [-x/--date-after <YYYYMMDD>]    Download only videos uploaded on or after
                                    this date. The date formats accepted is the
                                    same as --date

    [-o/--output-folder <path>]     Path to folder to output under.

    [-l/--login-using <path>]       Path to browser folder for yt-dlp extract cookies from.
                                    chrome
                                    chrome:~/.config/google-chrome
                                    chrome:~/.var/app/com.google.Chrome/
                                    firefox
                                    firefox:~/.var/app/org.mozilla.firefox/

    <url> [url] <list_file> [list_file]
EOF
}

script_name="${0##*/}"

declare -a required_cmds=( "ffmpeg" "yt-dlp" )
declare -a approved_res_args=( '480' '720' '1080' '1440' '2160' '4k' '4320' '8k' )

abort=false

simulate='false'
list_formats='false'
compress='false'
resolution='2160' # default 2160p / 4k
write_thumbnail='false'
write_description='false'
no_sort='false'
audio='false'
playlist_items=''
date=''
date_before=''
date_after=''
output_folder="$( pwd )"
login_using=''
declare -a urls=()

for rc in "${required_cmds[@]}"; do
    if ! command -v "${rc}" &> /dev/null ; then
        printf "${BRed}[${script_name}] ::ERROR:: '${rc}' command not available! ${Color_Off}"
        abort=true
    fi
done

args=$(getopt -a -o hsfcr:tdnai:u:z:x:o:l: --long help,simulate,list-formats,compress,resolution:,write-thumbnail,write-description,no-folder,audio,playlist-items:,date:,date-before:,date-after:,output-folder:login-using: -- "$@")
if [[ $? -gt 0 ]]; then
    usage && exit 1
fi

eval set -- ${args}
while :
do
    case $1 in

        -h | --help              )  usage && exit 0
                                    shift
                                    ;;
        -s | --simulate          )  simulate='true'
                                    printf "[${script_name}] ${Blue}::INFO::${Color_Off} simulate: ${Yellow}%s${Color_Off}\n" "${simulate}"
                                    shift
                                    ;;
        -f | --list-formats      )  list_formats='true'
                                    simulate='true'
                                    printf "[${script_name}] ${Blue}::INFO::${Color_Off} list_formats: ${Yellow}%s${Color_Off}\n" "${list_formats}"
                                    shift
                                    ;;
        -c | --compress          )  compress='true'
                                    if ! command -v "vzip" &> /dev/null ; then
                                        printf "${BRed}[${script_name}] ::ERROR:: 'vzip' command not available! ${Color_Off}"
                                        abort=true
                                    else
                                        printf "[${script_name}] ${Blue}::INFO::${Color_Off} compress: ${Yellow}%s${Color_Off}\n" "${compress}"
                                    fi
                                    shift
                                    ;;
        -r | --resolution        )  resolution="${2}"
                                    if ! printf '%s\n' "${approved_res_args[@]}" | grep -q "${resolution}" ; then
                                        printf "[${script_name}] ${Blue}::ERROR::${Color_Off} resolution: ${Red}%s${Color_Off}\n" "${resolution}"
                                        abort=true
                                    else
                                        printf "[${script_name}] ${Blue}::INFO::${Color_Off} resolution: ${Yellow}%s${Color_Off}\n" "${resolution}"
                                    fi
                                    shift 2
                                    ;;
        -t | --write-thumbnail   )  write_thumbnail='true'
                                    printf "[${script_name}] ${Blue}::INFO::${Color_Off} write_thumbnail: ${Yellow}%s${Color_Off}\n" "${write_thumbnail}"
                                    shift
                                    ;;
        -d | --write-description )  write_description='true'
                                    printf "[${script_name}] ${Blue}::INFO::${Color_Off} write_description: ${Yellow}%s${Color_Off}\n" "${write_description}"
                                    shift
                                    ;;
        -n | --no-folder         )  no_sort='true'
                                    printf "[${script_name}] ${Blue}::INFO::${Color_Off} no_sort: ${Yellow}%s${Color_Off}\n" "${no_sort}"
                                    shift
                                    ;;
        -a | --audio             )  audio='true'
                                    printf "[${script_name}] ${Blue}::INFO::${Color_Off} audio: ${Yellow}%s${Color_Off}\n" "${audio}"
                                    shift
                                    ;;
        -i | --playlist-items    )  playlist_items="${2}"
                                    printf "[${script_name}] ${Blue}::INFO::${Color_Off} playlist_items: ${Yellow}%s${Color_Off}\n" "${playlist_items}"
                                    shift 2
                                    ;;
        -u | --date              )  date="${2}"
                                    printf "[${script_name}] ${Blue}::INFO::${Color_Off} date: ${Yellow}%s${Color_Off}\n" "${date}"
                                    shift 2
                                    ;;
        -z | --date-before       )  date_before="${2}"
                                    printf "[${script_name}] ${Blue}::INFO::${Color_Off} date_before: ${Yellow}%s${Color_Off}\n" "${date_before}"
                                    shift 2
                                    ;;
        -x | --date-after        )  date_after="${2}"
                                    printf "[${script_name}] ${Blue}::INFO::${Color_Off} date_after: ${Yellow}%s${Color_Off}\n" "${date_after}"
                                    shift 2
                                    ;;
        -o | --output-folder     )  output_folder="$( expand_path "${2}" )"
                                    if [[ ! -d "${output_folder}" ]]; then
                                        printf "[${script_name}] ${Red}::ERROR::${Color_Off} output_folder: ${Red}%s${Color_Off}\n" "${output_folder}"
                                        abort=true
                                    else
                                        printf "[${script_name}] ${Blue}::INFO::${Color_Off} output_folder: ${Yellow}%s${Color_Off}\n" "${output_folder}"
                                    fi
                                    shift 2
                                    ;;
        -l | --login-using       )  login_using="${2}"
                                    if [[ "${login_using}" == *":"* && ! -d "$( expand_path "$( cut -d ':' -f 2 "${login_using}" )" )" ]]; then
                                        printf "[${script_name}] ${Red}::ERROR::${Color_Off} login_using: ${Red}%s${Color_Off}\n" "${login_using}"
                                        abort=true
                                    fi
                                    printf "[${script_name}] ${Blue}::INFO::${Color_Off} login_using: ${Yellow}%s${Color_Off}\n" "${login_using}"
                                    shift 2
                                    ;;
        # -- means the end of the arguments; drop this, and break out of the while loop
        --  )   shift; break
                ;;
        *   )   printf "${BRed}[${script_name}] ::ERROR:: Unsupported option: %s${Color_Off}\n" "${1}"
                usage
                abort=true
                ;;
    esac
done

if [[ $# -eq 0 ]]; then
    printf "${BRed}[${script_name}] ::ERROR:: No URLs provided!${Color_Off}\n"
    usage
    abort=true
else
    declare -a inputs+=( "$@" )
    for i in "${inputs[@]}"; do
        if [[ "$( is_url_urllib "${i}" )" == 'true' ]]; then
            urls+=( "${i}" )
            printf "[${script_name}] ${Blue}::INFO::${Color_Off} URL: %s\n" "${i}"
            continue
        fi

        batch_file="$( expand_path "${i}" )"
        if [[ -f "${batch_file}" ]]; then
            printf "[${script_name}] ${Blue}::INFO::${Color_Off} Batch file: %s\n" "${i}"
            mapfile -t batch_file_lines < <( cat "${i}" | awk NF ) # 'awk NF' removes empty or just spaces lines
            for bfl in "${batch_file_lines[@]}"; do
                if [[ ! "${bfl}" =~ ^[[:space:]]*\#.*$ ]]; then
                    if [[ "$( is_url_urllib "${bfl}" )" == 'true'  ]]; then
                        urls+=( "${bfl}" )
                        printf "[${script_name}] ${Blue}::INFO::${Color_Off} URL: %s\n" "${bfl}"
                    else
                        printf "[${script_name}] ${Red}::ERROR::${Color_Off} Unknown input: %s\n" "${bfl}"
                        abort=true
                    fi
                fi
            done
            continue
        fi

        printf "[${script_name}] ${Red}::ERROR::${Color_Off} Unknown input: %s\n" "${i}"
        abort=true
    done
fi

if [[ ${#urls[@]} -gt 0 ]]; then
    # Remove any duplicate entries
    mapfile -t unique_urls < <( printf '%s\n' "${urls[@]}" | sort -u )
else
    printf "[${script_name}] ${Red}::ERROR::${Color_Off} No URLs to process!\n"
    abort=true
fi

[[ "${abort}" == true ]] && exit 1

# If on Android/Termux trigger a wakelock which causes the system
# not to go into deep sleep which can mess long downloads.
if command -v "termux-wake-lock" &> /dev/null ; then
    termux-wake-lock
fi

if [[ "${compress}" == 'true' ]]; then
    items_to_compress="$( mktemp )"
    trap "rm -f ${items_to_compress}" 0 2 3 15  # 0/EXIT = Exit shell, 2/SIGINT = Interrupt, 3/SIGQUIT = Quit, 15/SIGTERM = Terminate
                                                # https://man7.org/linux/man-pages/man7/signal.7.html
                                                # https://unix.stackexchange.com/a/181939
fi

declare -a failed_items=()

url_index=0
for u in "${unique_urls[@]}"; do

    url_index=$((url_index + 1))

    # Show user where we are as far as links/args go
    printf "\n${BPurple}[%s/%s]${Color_Off} %s\n" "${url_index}" "${#unique_urls[@]}" "${u}"
    print_char_line '-'

    # Prepare yt-dlp config
    ytdlp_config="$( mktemp )"
    trap "rm -f ${ytdlp_config}" 0 2 3 15   # 0/EXIT = Exit shell, 2/SIGINT = Interrupt, 3/SIGQUIT = Quit, 15/SIGTERM = Terminate
                                            # https://man7.org/linux/man-pages/man7/signal.7.html
                                            # https://unix.stackexchange.com/a/181939
    cat > "${ytdlp_config}" <<'heredoc'
--prefer-free-formats
--restrict-filenames
--progress
--exec 'printf " ~> file://%s\n\n"'
heredoc

    if [[ "${compress}" == 'true' ]]; then
        cat >> "${ytdlp_config}" <<heredoc
--exec 'echo "%(filepath)q" >> ${items_to_compress}'
heredoc
    fi

    [[ "${list_formats}" == 'true' ]] && append_line_to_file '--list-formats' "${ytdlp_config}"
    [[ "${simulate}" == 'false' ]] && append_line_to_file '--no-simulate' "${ytdlp_config}"
    [[ "${write_thumbnail}" == 'true' ]] && append_line_to_file '--write-thumbnail' "${ytdlp_config}"
    [[ "${write_description}" == 'true' ]] && append_line_to_file '--write-description' "${ytdlp_config}"

    # Date filters can be applied to non-playlist multi-downloads like an entire channel
    [[ ! -z "${date}" ]] && append_line_to_file "--date ${date}" "${ytdlp_config}"
    [[ ! -z "${date_after}" ]] && append_line_to_file "--dateafter ${dateafter}" "${ytdlp_config}"
    [[ ! -z "${date_before}" ]] && append_line_to_file "--datedefore ${datebefore}" "${ytdlp_config}"

    [[ "${u}" =~ 'soundcloud.com' ]] && audio='true'


    # If not just audio & url comes with a specific resolution, check & use that
    if [[ "${audio}" == 'false' ]]; then
        cat >> "${ytdlp_config}" <<heredoc
--format-sort hdr:SDR,res:${resolution},fps:60,+vbr,acodec:opus,channels:2
--merge-output-format mkv
--remux-video mkv
--embed-thumbnail
--embed-chapters
--embed-subs
heredoc
    else
        cat >> "${ytdlp_config}" <<'heredoc'
--format 'ba/b'
--format-sort acodec:opus,abr
--merge-output-format mkv
--remux-video mka
--embed-thumbnail
--embed-chapters
heredoc
    fi

    # Filter out YouTube & Twitch links
    if [[ "${u}" =~ 'youtube.com' || "${u}" =~ 'youtu.be' ]]; then

        if [[ "${u}" =~ 'list=' ]]; then # Detect specific playlist
            [[ ! -z "${playlist_items}" ]] && append_line_to_file "--playlist-items ${playlist_items}" "${ytdlp_config}"

            [[ "${list_formats}" = 'false' ]] && echo -e "--print ' ${BWhite}[%(autonumber)s/%(n_entries)s]${Color_Off} %(uploader)s - %(playlist_title)s ${BPurple}//${Color_Off} %(title)s ${BPurple}//${Color_Off} %(resolution)s %(fps)sfps (%(vcodec)s,%(acodec)s) ${BPurple}//${Color_Off} %(duration_string)s'" >> "${ytdlp_config}"

            if [[ "${no_sort}" == 'true' ]]; then
                append_line_to_file "-o '${output_folder}/%(uploader)s-%(playlist_title)s-%(playlist_index)s_of_%(playlist_count)s-%(upload_date)s-%(title)s.%(ext)s'" "${ytdlp_config}"
            else
                if [[ "${audio}" == 'true' ]]; then
                    append_line_to_file "-o '${output_folder}/ydl/audio/youtube/%(uploader)s/%(playlist_title)s/%(playlist_title)s-%(playlist_index)s_of_%(playlist_count)s-%(upload_date)s-%(title)s.%(ext)s'" "${ytdlp_config}"
                else
                    append_line_to_file "-o '${output_folder}/ydl/video/youtube/%(uploader)s/%(playlist_title)s/%(playlist_title)s-%(playlist_index)s_of_%(playlist_count)s-%(upload_date)s-%(title)s.%(ext)s'" "${ytdlp_config}"
                fi
            fi

        else # Single videos, channels, etc.

            [[ "${list_formats}" == 'false' ]] && echo -e "--print ' %(uploader)s - %(title)s ${BPurple}//${Color_Off} %(resolution)s %(fps)sfps (%(vcodec)s,%(acodec)s) ${BPurple}//${Color_Off} %(duration_string)s'" >> "${ytdlp_config}"
            if [[ "${no_sort}" == 'true' ]]; then
                append_line_to_file "-o '${output_folder}/%(uploader)s-%(upload_date)s-%(title)s.%(ext)s'" "${ytdlp_config}"
            else
                if [[ "${audio}" == 'true' ]]; then
                    append_line_to_file "-o '${output_folder}/ydl/audio/youtube/%(uploader)s/%(upload_date)s-%(title)s.%(ext)s'" "${ytdlp_config}"
                else
                    append_line_to_file "-o '${output_folder}/ydl/video/youtube/%(uploader)s/%(upload_date)s-%(title)s.%(ext)s'" "${ytdlp_config}"
                fi
            fi
        fi

    elif [[ "${u}" =~ 'twitch.tv' ]]; then

        [[ "${list_formats}" == 'false' ]] && echo -e "--print ' %(uploader)s - %(title)s ${BPurple}//${Color_Off} %(resolution)s %(fps)sfps (%(vcodec)s,%(acodec)s) ${BPurple}//${Color_Off} %(duration_string)s'" >> "${ytdlp_config}"
        if [[ "${no_sort}" == 'true' ]]; then
            append_line_to_file "-o '${output_folder}/%(uploader)s-%(upload_date)s-%(timestamp)s-%(title)s.%(ext)s'" "${ytdlp_config}"
        else
            if [[ "${audio}" == 'true' ]]; then
                append_line_to_file "-o '${output_folder}/ydl/audio/twitch/%(uploader)s/%(upload_date)s-%(timestamp)s-%(title)s.%(ext)s'" "${ytdlp_config}"
            else
                append_line_to_file "-o '${output_folder}/ydl/video/twitch/%(uploader)s/%(upload_date)s-%(timestamp)s-%(title)s.%(ext)s'" "${ytdlp_config}"
            fi
        fi

    elif [[ "${u}" =~ 'tiktok.com' ]]; then

        [[ "${list_formats}" == 'false' ]] &&  echo -e "--print ' %(uploader)s - %(title)s ${BPurple}//${Color_Off} %(resolution)s %(fps)sfps (%(vcodec)s,%(acodec)s) ${BPurple}//${Color_Off} %(duration_string)s'" >> "${ytdlp_config}"
        if [[ "${no_sort}" == 'true' ]]; then
            append_line_to_file "-o '${output_folder}/%(uploader)s-%(upload_date)s-%(title)s.%(ext)s'" "${ytdlp_config}"
        else
            if [[ "${audio}" == 'true' ]]; then
                append_line_to_file "-o '${output_folder}/ydl/audio/tiktok/%(uploader)s/%(upload_date)s-%(title)s.%(ext)s'" "${ytdlp_config}"
            else
                append_line_to_file "-o '${output_folder}/ydl/video/tiktok/%(uploader)s/%(upload_date)s-%(title)s.%(ext)s'" "${ytdlp_config}"
            fi
        fi

    elif [[ "${u}" =~ 'soundcloud.com' ]]; then

        if [[ "${u}" =~ '/sets/' ]]; then # playlist
            [[ "${list_formats}" == 'false' ]] && echo -e "--print ' ${BWhite}[%(autonumber)s/%(n_entries)s]${Color_Off} %(uploader)s - %(playlist_title)s ${BPurple}//${Color_Off} %(title)s ${BPurple}//${Color_Off} %(acodec)s ${BPurple}//${Color_Off} %(duration_string)s'" >> "${ytdlp_config}"
            if [[ "${no_sort}" == 'true' ]]; then
                append_line_to_file "-o '${output_folder}/%(playlist_title)s--%(uploader)s--%(playlist_index)s_of_%(playlist_count)s--%(title)s.%(ext)s'" "${ytdlp_config}"
            else
                append_line_to_file "-o '${output_folder}/ydl/audio/soundcloud/%(playlist_title)s--%(uploader)s/%(playlist_index)s_of_%(playlist_count)s--%(title)s.%(ext)s'" "${ytdlp_config}"
            fi
        else # single item
            [[ "${list_formats}" == 'false' ]] && echo -e "--print ' %(uploader)s - %(title)s ${BPurple}//${Color_Off} %(acodec)s ${BPurple}//${Color_Off} %(duration_string)s'" >> "${ytdlp_config}"
            if [[ "${no_sort}" == 'true' ]]; then
                append_line_to_file "-o '${output_folder}/%(uploader)s--%(title)s.%(ext)s'" "${ytdlp_config}"
            else
                append_line_to_file "-o '${output_folder}/ydl/audio/soundcloud/%(uploader)s/%(title)s.%(ext)s'" "${ytdlp_config}"
            fi
        fi

    else

        # Some other source
        [[ "${list_formats}" == 'false' ]] && echo -e "--print ' %(title)s ${BPurple}//${Color_Off} %(resolution)s %(fps)sfps (%(vcodec)s,%(acodec)s)${BPurple}//${Color_Off} %(duration_string)s'" >> "${ytdlp_config}"
        append_line_to_file "-o '${output_folder}/%(title)s.%(ext)s'" "${ytdlp_config}"

    fi

    if [[ -n "${login_using}" ]]; then
        if ! yt-dlp --cookies-from-browser "${login_using}" --config-location "${ytdlp_config}" "${u}" ; then
            failed_items+=("[${url_index}/${#unique_urls[@]}] ${u}")
        fi
    else
        if ! yt-dlp --config-location "${ytdlp_config}" "${u}" ; then
            failed_items+=("[${url_index}/${#unique_urls[@]}] ${u}")
        fi
    fi

    # Remove yt-dlp config file
    rm -rf "${ytdlp_config}"

done

# Show failed items
if [[ ${#failed_items[@]} -gt 0 ]]; then
    echo
    print_char_line '='
    printf "${BRed}Failed items:${Color_Off} %d\n" ${#failed_items[@]}
    printf '%s\n' "${failed_items[@]}" # | \column -t -s '|'
fi

# Do compression of all succesful items
if [[ "${compress}" == 'true' ]]; then

    if [[ ! -f "${items_to_compress}" ]]; then
        printf "[${script_name}] ${Red}::ERROR::${Color_Off} Temp file with items to compress is missing: %s\n" "${items_to_compress}"
    else
        mapfile -t items_to_compress_lines < <( cat "${items_to_compress}" | awk NF ) # 'awk NF' removes empty or just spaces lines
        if [[ ${#items_to_compress_lines[@]} -eq 0 ]]; then
            printf "[${script_name}] ${Red}::ERROR::${Color_Off} Temp file with items to compress is missing: %s\n" "${items_to_compress}"
        else
            echo -e "\n${BGreen}Compressing items:${Color_Off} ${#items_to_compress_lines[@]}"
            print-line '-'
            vx265opus "${items_to_compress_lines[@]}"
        fi
    fi

fi

# Notify done
if command -v "termux-wake-unlock" &> /dev/null ; then
    termux-wake-unlock
fi
if command -v "termux-notification" &> /dev/null ; then
    termux-notification --id ydl_done --led-color FFFFFF --sound --title 'ydl DONE' --content 'Enjoy your content!'
fi

exit 0